[{"categories":["Java"],"contents":" 今天的 Spring Card 要完成SA文件，例外處理檢核邏輯的開發，其中有個需求蠻有趣的：「若不符合 XX日減一年 ≦ XX日 ≦ XX日加一個月，出現錯誤訊息：「(錯誤代號)-已超過XX日可輸入範圍」」 這讓我苦惱了很久，大約兩三個小時去了～ 最後我想到個很土炮的方法，反正字串傳進來是yyyyMMdd，那我就轉成數字，也就是\u0026quot;20230819\u0026quot; -\u0026gt; 20230819 然後減10000 就會變成20220819 若加100月份就會是9月\n20230819 - 10000 = 20220819 20230819 + 100 = 20230919 完美 好啦～今天可以準時下班啦 YA if((Integer.parseInt(date) - 10000 \u0026lt;= Integer.parseInt(date) || Integer.parseInt(date) \u0026lt;= Integer.parseInt(date) + 100)){ /** 內容已被和諧 **/ throw Exception; } 厲害吧！我根本是個天才 熱騰騰端去給學長看，想當然而先被釘在天花板上啦qaq 「你這種作法在極端情況下，會出問題的。」\n學長，人家錯惹，再也不敢了嗚嗚嗚嗚嗚 想一想是沒錯啦！不然12月變成13月也是蠻恐怖的XDDDD 所以調整作法，使用LocalDate這個物件，來達成SA文件上的需求 DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\u0026#34;yyyyMMdd\u0026#34;) LocalDate date = LocalDate.parse(getDate(), dtf); LocalDate localDate = LocalDate.now(ZoneId.of(\u0026#34;Asia/Taipei\u0026#34;)); //未來寫個Methods 依據國別判斷導入之時區 LocalDate plusMonths = localDate.plusMonths(1); LocalDate minusYears = localDate.minusYears(1); if(minusYears.compareTo(date) \u0026gt;= 0 || plusMonths.compareTo(date) \u0026lt;= 0){ /** 內容已被和諧 **/ throw Exception; } } 我先用把字串的20230819轉型為LocalDate 宣告個變數localDate取得指定時區的現在時間 依SA文件需求，宣告plusMonths與minusYears變數，並使用plusMonths(), minusYears()這兩個Methods 最後再善用 compareTo 比較 -1 0 1之間的運算子，如：\u0026gt;, \u0026lt;, =, \u0026gt;=, \u0026lt;=, !=，來達成檢核邏輯的判斷 請把設計好的錯誤代號與訊息，狠狠地砸到前端廠商身上:) compareTo Example public static void main(String[] args) { // 建立兩個日期 Date date = new Date(108, 6, 11); Date date1 = new Date(109, 3, 19); // 宣告三個比較時間的變數 //時間小compareTo時間大 int num1 = date.compareTo(date1); //時間大compareTo時間小 int num2 = date1.compareTo(date); //同個時間compareTo同個時間 int num3 = date.compareTo(date); // 列印結果 System.out.println(\u0026#34;Num is:\u0026#34; + num1); System.out.println(\u0026#34;Num is:\u0026#34; + num2); System.out.println(\u0026#34;Num is:\u0026#34; + num3); } } 列印結果 Num is:-1 Num is:1 Num is:0 好啦以後就能用compareTo去玩一堆檢核邏輯的花招啦～今天就分享到這，謝謝觀看 ","permalink":"https://ytaoCrow.github.io/blog/%E5%A6%82%E4%BD%95%E9%80%8F%E9%81%8E%E9%81%8B%E7%AE%97%E5%AD%90/","tags":["Java"],"title":"使用compareTo運算子，達成各種日期檢核的奇怪需求 | Java"},{"categories":["SpringBoot"],"contents":" SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/C:/Users/XXXXXX/.m2/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/C:/Users/XXXXXX/.m2/org/apache/logging/log4j/log4j-slf4j-impl/2.13.3/log4j-slf4j-impl-2.13.3.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. SLF4J: Actual binding is of type [ch.qos.logback.classic.util.ContextSelectorStaticBinder] public static void main(String[] args) { System.out.println(\u0026ldquo;Hello world!\u0026rdquo;); }\n問題原因在於專案引用了兩個日誌框架，例如上面訊息說找到兩個slf4j binding，分別為：\nlogback-classic-1.2.3.jar log4j-slf4j-impl-2.11.2.jar。 因為slf4j一次只能綁定一個日誌框架，若slf4j在專案的classpath找到兩個日誌框架就會出現以上警告訊息。不過slf4j仍會選擇其中一個來綁定，例如上面最終綁定logback。\n若要避免出現警告訊息，必須排除其中一個日誌框架依賴。\n設定以下即可排除： 在Starter底下exclusion排除掉starter-logging \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 加入Log4j2 dependency \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;!-- Maven專案中若有spring-boot-starter依賴且已排除了spring-boot-starter-logging，下面就不用設定了 \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; --\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log4j2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; ... \u0026lt;/dependencies\u0026gt; Spring Boot預設的日誌輸出等級是INFO。但若Sprinb Boot改用了log4j2框架並添加了設定檔如log4j2.properties，即使在沒作任何設定的情況下，Logger預設等級會改為log4j2的預設等級ERROR。 在src/main/resources下新增log4j2.properties並設定以下在console輸出日誌： log4j2.properites appender.console.type = Console appender.console.name = STDOUT appender.console.layout.type = PatternLayout appender.console.layout.pattern = %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n rootLogger.level = INFO rootLogger.appenderRefs = stdout rootLogger.appenderRef.stdout.ref = STDOUT Reference： Spring Boot SLF4J: Class path contains multiple SLF4J bindings. Spring Boot Log4j2 Maven Gradle dependencies 設定 Spring Boot 預設的日誌級別 default log level ","permalink":"https://ytaoCrow.github.io/blog/%E5%95%9F%E5%8B%95spring-boot%E5%B0%88%E6%A1%88%E6%99%82/","tags":["SpringBoot","SLF4J","Java"],"title":"啟動Spring Boot專案時，出現錯誤SLF4J: Class path contains multiple SLF4J bindings."},{"categories":null,"contents":"","permalink":"https://ytaoCrow.github.io/blog/post-13/","tags":null,"title":""}]